<?php
// Вставка в страницу HTML кода на основе темплейтов
// Параметры:
// $template - темплейт с HTML кодом, который будет использоваться как основа
// $params - массив с данными, которые будут использоваться для подстановки.
function insertTemplate($template,$params=array()) {
// Убираем из текста темплейта все escaped символы (они будут заменены
// на необходимые значения позже) Это необходимо, чтобы облегчить задачу
// разбиения темплейтов с помощью регулярных выражений
 $template = strtr($template,array('{{'=>"\x03",'}}'=>"\x04"));
// Используем регулярное выражение чтобы получить массив всех мест внутри темплейта,
// которые должны быть заменены на результаты подстановки.
 preg_match_all("/\{([^\}]+)\}/i",$template,$matches);
// Если не было найдено ни одного места для подстановки -
// просто возвращаем исходный текст темплейта.
 if (sizeof($matches[0])==0)
 return($template);
// В этот массив мы будем собирать тексты, которые будут исползованы для
// подстановок в темплейт.
 $replaces = array();
// Нам необходимо преобразовать все найденные места для подстановок внутри темплейта
// в регулярные выражения для их поиска. Тогда мы сможем впоследствии выполнить
// все подстановки одновременно, используя замену по массиву регулярных выражений.
 for ($i=0;$i<sizeof($matches[0]);$i++)
 $matches[0][$i] = '/'.preg_quote($matches[0][$i],'/').'/';
// Теперь нам необходимо подготовить тексты для замены
// Для этого нам необходимо обработать содержимое каждого из найденных
// мест для подстановок внутри темплейта.
 for ($i=0;$i<sizeof($matches[1]);$i++)
 {
// Преобразуем все escaped символы в нормальные. Символ разделения ' ' при этом
// заменяем на символ с кодом 0x01, чтобы не перепутать.
 $match = strtr(strtr($matches[1][$i],array(' '=>"\x02",' '=>"\x01")),"\x02",' ');
// Проверяем, что из себя представляет строка, которую мы пытаемся обработать
 if (strpos($match,"\x01")!==false)
// Эта строка содержит в себе несколько частей. Это значит, что кроме имени эта
// строка содержит какие-то параметры, которые требуют дополнительной обработки.
 {
// Поскольку основная синтаксическая структура у нас состоит из 2 частей - имени
// и значения по-умолчанию - получаем эти две основные части в виде отдельных переменных
 list($key,$default) = explode("\x01",$match,2);
// Исправляем regular expression для дальнейшей замены
 $matches[0][$i] = "/\{$key\ [^\}]+\}/";
// Проверяем, чем является параметр, переданный внутри темплейта. Если он начинается
// с одного из специальных символов, то необходима дополнительная обработка этого значения.
// Однако это необходимо делать толлько в случае, если в переданных в функцию данных для
// замены нет текста для этой подстановки (потому что данные, переданные в качестве
// аргумента имеют более высокий приоритет).
 if ((in_array($default[0],array('#','!'))) && (!isset($params[$key])))
 {
// Получаем список аргументов. Первый символ отбраcываем, потому что это признак
// спеуиальной обработки и не относится к имени.
 $words = explode("\x01",substr($default,1));
// Поскольку первым в полученном списке стоит имя, которое будет использоваться
// обработчиком - берем его в отдельную переменную и убираем из массива аргументов.
// Теперь в массиве $words - только список аргументов.
 $name = array_shift($words);
// Проверяем, если количество аргументов - нечетное (т.е. нам необходим еще один, поскольку
// все аргументы рассматриваются как пары "имя-значение"), то добавляем пустую строку.
 if ((sizeof($words)%2)!=0)
 $words[] = '';
// Формируем массив параметров. Он должен быть в том же виде, в котором он передается
// в данную функцию (т.е. имя параметра задается в виде ключа ассоциативного массива).
 $params = array();
 for ($j=0;$j<sizeof($words);$j+=2)
 $params[$words[$j]] = $words[$j+1];
 if ($default[0]=='#')
// Символ '#' указывает на необходимость вставки темплейта с заданным именем
 $default = insertTemplate($GLOBALS[$name],$params);
 elseif ($default[0]=='!')
// Символ '#' указывает на необходимость вставки результатов работы пользовательской
// функции с заданным именем
 $default = call_user_func($name,$params);
 };
// Если в списке текстов для подстановки, переданных в качестве параметра в эту функцию,
// есть текст для подстановки с таким же именем, то используем его, потому что параметры,
// переданные в качестве аргумента имеют более высокий приоритет. Если же такого текста
// нет, то используем текст, имеющийся у нас в качестве значения.
 $replaces[] = (isset($params[$key]))?$params[$key]:$default;
 }
 elseif ($match=='l')
// Эта строка - escaping для левой фигурной скобки, имеющей специальное значение.
 $replaces[] = '{';
 elseif ($match=='r')
// То же самое для правой фигурной скобки
 $replaces[] = '}';
 else
// Эта строка имеет только имя. Если в списке текстов для подстановки, переданных
// в качестве параметра в эту функцию, есть текст для подстановки с таким именем,
// то используем его, в противном случае используем в качестве замены пустую строку.
 $replaces[] = (isset($params[$match]))?$params[$match]:"";
 };
// Теперь у нас есть все необходимые данные и мы можем выполнить замену. Поскольку все
// строки, которые необходимо заменить в данном темплейте сконвертированы в регулярные
// выражения - необходимо просто выполнить замену по имеющимся массивам. Кроме того
// здесь же мы возвращаем нормальные значения escaped символам, которые мы убирали в начале.
 return(strtr(preg_replace($matches[0],$replaces,$template),array("\x03"=>'{',"\x04"=>'}')));
}; ?>